# SearchSocket Specification

Semantic site search and AI-agent content retrieval for SvelteKit static sites (CMS-less workflow)

## 1. Purpose

SearchSocket is an open-source, SvelteKit-first system that provides:

1. **Published site search**: a “Google-like” search endpoint for large static SvelteKit sites, powered by embeddings + vector search + optional reranking.

2. **Developer/agent search (MCP)**: an MCP server that lets AI coding agents quickly locate relevant content and **returns the original SvelteKit route root file** (e.g., `src/routes/**/+page.svelte`) associated with the indexed content.

SearchSocket assumes content is managed in git (and/or generated by SvelteKit), with AI coding agents acting as the “CMS interface.” SearchSocket supplies the missing piece: fast, accurate search with incremental indexing, branch scoping, and safe cost controls.

---

## 2. Product Principles

* **Simple to adopt**: minimal configuration; one install; one hook to expose `/api/search`; one CLI to index.
* **Incremental by default**: never re-embed unchanged content; reuse cached embeddings when possible.
* **Branch scoping is opt-in**: default indexes only `main`.
* **“Google-like” behavior**: results are ranked pages/sections; supports restricting search to a directory (path prefix), like `site:example.com/docs`.
* **Source-of-truth Markdown mirror**: indexing produces a deterministic Markdown representation stored locally; changes are detected by file hashes in this mirror.
* **Safe agent surface**: MCP exposes retrieval only (search + page fetch). Indexing remains a CLI concern.
* **Serverless-friendly vector backends**: first-class support for **Pinecone** and **Milvus Cloud/Zilliz Cloud**; plus a local/offline backend for development.

---

## 3. Scope

### 3.1 Supported site type

* Primary: SvelteKit sites that can be built as static output (adapter-static or equivalent).
* Secondary: SvelteKit sites that can be crawled from a preview server.
* Not required: full dynamic per-user pages behind auth.

### 3.2 Supported languages

* English-first. (Embedding models can be swapped later; no multilingual features are assumed in MVP.)

### 3.3 Open source requirements

* All SearchSocket code is open source.
* External services (OpenAI embeddings, Pinecone, Milvus Cloud, Jina reranker) may be used via API; SearchSocket itself remains open source.

---

## 4. Deliverables (Single Package)

Publish a single npm package:

* **`searchsocket`**

  * CLI (`searchsocket` binary)
  * SvelteKit integration (`searchsocket/sveltekit`)
  * MCP server (`searchsocket mcp`)
  * Vector adapters (Pinecone, Milvus Cloud/Zilliz, Local)
  * Optional reranker (Jina, None)
  * Internal interfaces for future extensibility (not separate packages)

> Avoid using the name “searchkit” or `@searchkit/*` due to confusion with an existing project.

---

## 5. Installation and Minimal Integration

### 5.1 Install

* `pnpm add -D searchsocket`
* (or npm/yarn equivalent)

### 5.2 Minimal config (`searchsocket.config.ts`)

A minimal config must work:

```ts
export default {
  embeddings: { apiKeyEnv: "OPENAI_API_KEY" },
  vector: { provider: "pinecone" } // or "milvus" or "local"
};
```

Everything else is inferred by defaults.

### 5.3 Expose search endpoint via SvelteKit hook (default path `/api/search`)

In `src/hooks.server.ts`:

```ts
import { searchsocketHandle } from "searchsocket/sveltekit";

export const handle = searchsocketHandle();
```

This intercepts `POST /api/search` and responds with JSON results.

---

## 6. Key Concepts

### 6.1 Scope (branch isolation)

A **scope** is the indexing namespace. Default is `main`. Scopes may be branch-based.

* `projectId`: inferred from `package.json` name unless configured
* `scopeName`: default `main`, or derived from git branch/env var if enabled
* `scopeId`: `${projectId}:${scopeName}`

Branch scoping is **opt-in**.

### 6.2 Markdown Mirror (source of truth for indexing)

SearchSocket generates and maintains a deterministic Markdown representation of each page under:

* `.searchsocket/pages/<scopeName>/...`

Each page becomes a `.md` file with:

* frontmatter metadata (URL, title, route file mapping, etc.)
* extracted main content converted to Markdown (boilerplate removed)

Incremental indexing uses this directory to detect what changed and what must be re-embedded.

### 6.3 Units of retrieval

* **Page**: canonical URL path (e.g., `/docs/getting-started`)
* **Chunk**: a section of page content (heading + content block), used as the retrieval unit in the vector store

---

## 7. Configuration Specification

Configuration file: `searchsocket.config.ts`

All fields are optional unless noted.

```ts
export default {
  project: {
    id?: string;                 // default: package.json name
    baseUrl?: string;            // optional canonical base URL
  },

  scope: {
    mode?: "fixed" | "git" | "env"; // default: "fixed"
    fixed?: string;                 // default: "main"
    envVar?: string;                // used when mode="env"
    sanitize?: boolean;             // default true
  },

  source: {
    mode?: "static-output" | "crawl" | "content-files"; // default auto-detect
    staticOutputDir?: string;       // default "build" (or adapter output)
    crawl?: {
      baseUrl: string;              // e.g. http://localhost:4173
      routes?: string[];            // explicit routes list
      sitemapUrl?: string;          // e.g. /sitemap.xml
    };
    contentFiles?: {
      globs: string[];              // e.g. ["src/routes/**/+page.svelte", "content/**/*.md"]
      baseDir?: string;             // default project root
    };
  },

  extract: {
    mainSelector?: string;          // default "main"
    dropTags?: string[];            // default ["header","nav","footer","aside"]
    dropSelectors?: string[];       // default common sidebar/toc/breadcrumb selectors
    ignoreAttr?: string;            // default "data-search-ignore"
    noindexAttr?: string;           // default "data-search-noindex"
    respectRobotsNoindex?: boolean; // default true
  },

  transform: {
    output?: "markdown";            // always markdown in MVP
    preserveCodeBlocks?: boolean;   // default true
    preserveTables?: boolean;       // default true
  },

  chunking: {
    strategy?: "hybrid";            // only supported strategy in MVP
    maxChars?: number;              // default 2200
    overlapChars?: number;          // default 200
    minChars?: number;              // default 250
    headingPathDepth?: number;      // default 3
    dontSplitInside?: ("code"|"table"|"blockquote")[]; // default all
  },

  embeddings: {
    provider?: "openai";            // only provider in MVP
    model?: string;                 // default "text-embedding-3-small"
    apiKeyEnv?: string;             // default "OPENAI_API_KEY"
    batchSize?: number;             // default 64
    concurrency?: number;           // default 8
  },

  vector: {
    provider: "pinecone" | "milvus" | "local";

    pinecone?: {
      apiKeyEnv?: string;           // default "PINECONE_API_KEY"
      index?: string;               // default `${projectId}`
      namespaceMode?: "scope";      // always scope in MVP
    };

    milvus?: {
      uriEnv?: string;              // default "MILVUS_URI"
      tokenEnv?: string;            // default "MILVUS_TOKEN"
      collection?: string;          // default `${projectId}_chunks`
    };

    local?: {
      path?: string;                // default ".searchsocket/local-vectors.json"
    };
  },

  rerank: {
    provider?: "none" | "jina";     // default "none"
    topN?: number;                  // default 20
    jina?: {
      apiKeyEnv?: string;           // default "JINA_API_KEY"
      model?: string;               // default "jina-reranker-v2-base-multilingual"
    };
  },

  ranking: {
    enableIncomingLinkBoost?: boolean; // default true
    enableDepthBoost?: boolean;        // default true
    weights?: {
      incomingLinks?: number;          // default 0.05
      depth?: number;                  // default 0.03
      rerank?: number;                 // default 1.0 (when rerank enabled)
    };
  },

  api: {
    path?: string;                   // default "/api/search"
    cors?: { allowOrigins?: string[] };
    rateLimit?: { windowMs?: number; max?: number };
  },

  mcp: {
    enable?: boolean;                // default true in dev, false in prod
    transport?: "stdio" | "http";    // default "stdio"
    http?: { port?: number; path?: string };
  },

  state: {
    dir?: string;                    // default ".searchsocket"
  },
};
```

---

## 8. Indexing Pipeline

### 8.1 Index command

`searchsocket index`

Primary responsibilities:

1. Build or locate page sources (static output, crawl, or content files)
2. Extract main content and convert to deterministic Markdown
3. Write Markdown mirror files to `.searchsocket/pages/<scope>/...`
4. Chunk Markdown into retrieval chunks
5. Incrementally embed changed chunks only (with embedding cache)
6. Upsert vectors and metadata into the vector backend
7. Delete stale vectors no longer present
8. Update local manifest and scope registry
9. Print cost estimates and run summary

### 8.2 Source modes

#### A) `static-output` (default when build output exists)

* Read HTML files from `source.staticOutputDir`
* Derive URL path from file path:

  * `build/index.html` → `/`
  * `build/docs/getting-started/index.html` → `/docs/getting-started`
  * `build/docs/foo.html` → `/docs/foo` (if present)
* Parse HTML, extract content, convert to Markdown

#### B) `crawl`

* Fetch routes from `crawl.routes` OR parse sitemap from `crawl.sitemapUrl`
* For each route, fetch HTML from `crawl.baseUrl + route`
* Extract and convert to Markdown

#### C) `content-files` (best for MCP source mapping)

* Parse known content sources directly:

  * Markdown files: use Markdown as-is (normalized)
  * Svelte route files: extract meaningful content if feasible (optional), otherwise use crawl/static-output for content but use `content-files` to map route ownership
* Always map URL → route root file (`+page.svelte`) for MCP return payloads.

> Recommended: Use `static-output` or `crawl` for content, and additionally enable route mapping by scanning `src/routes/**/+page.svelte` to associate URL paths to route files.

### 8.3 Boilerplate stripping and author controls

Extraction defaults:

* Prefer subtree matching `extract.mainSelector` (`main` by default)
* Remove nodes by:

  * tag: `header`, `nav`, `footer`, `aside`
  * selectors: `.sidebar`, `.toc`, `.breadcrumbs`, etc.
* Remove nodes with attribute `extract.ignoreAttr` (`data-search-ignore`)
* Skip page if:

  * `<meta name="robots" content="noindex">` and `respectRobotsNoindex = true`
  * any element has `data-search-noindex`

### 8.4 Deterministic Markdown mirror format

For each page at URL path `/docs/getting-started`, write:

`.searchsocket/pages/<scope>/docs/getting-started.md`

Frontmatter schema:

```yaml
---
url: "/docs/getting-started"
title: "Getting Started"
scope: "main"
routeFile: "src/routes/docs/getting-started/+page.svelte"
generatedAt: "2026-02-10T00:00:00Z"
incomingLinks: 8
outgoingLinks: 12
depth: 2
tags: ["docs"]
---
```

Body:

* Clean Markdown extracted from the page main content (boilerplate removed)
* Preserve fenced code blocks and tables
* Normalize whitespace; stable heading formatting

This Markdown mirror is the canonical input for chunking and hashing.

---

## 9. Chunking

### 9.1 Hybrid strategy (boundary-aware)

Chunking operates on Markdown mirror files.

Algorithm:

1. Split by headings (`#`, `##`, `###`, …).
2. For each heading section:

   * if section length ≤ `maxChars`: emit one chunk
   * else split by paragraph boundaries into chunks with `overlapChars`
3. If page has no headings:

   * split entire body by paragraph boundaries
4. Do not split inside:

   * fenced code blocks
   * tables
   * blockquotes
5. Store heading path capped to `headingPathDepth` (default 3).

### 9.2 Chunk fields

Each chunk has:

* `url`
* `title` (page title)
* `sectionTitle` (heading title for chunk, if present)
* `headingPath` (array capped depth)
* `chunkText` (Markdown/text content)
* `snippet` (first N characters, cleaned)
* `depth` (path segments count)
* `incomingLinks` (page-level)
* `routeFile` (SvelteKit `+page.svelte` root file path)

---

## 10. Incremental Indexing and Caching

### 10.1 Content hash

Compute:

* `contentHash = sha256(normalizedChunkText)`

This determines whether the embedding can be reused.

### 10.2 Chunk key (vector record ID)

Use a deterministic ID intended to be stable per page and chunk order:

* `chunkKey = sha1(scopeName + "|" + url + "|" + chunkOrdinal + "|" + sectionTitleNormalized)`

Where:

* `chunkOrdinal` is the order of emitted chunks for that page
* `sectionTitleNormalized` is empty if no heading exists

This supports predictable upserts and deletions. Embedding reuse is handled by the content cache even if ordinals shift.

### 10.3 Embedding cache (required)

Maintain a local cache mapping `contentHash + modelId → embeddingVector`.

Storage:

* `.searchsocket/embeddings-cache.json` (preferred)
* Must support:

  * lookup by `contentHash` and `modelId`
  * store vector bytes efficiently
  * store `tokenEstimate` used for cost summaries

### 10.4 Manifest

Maintain `.searchsocket/manifest.json` with:

* `projectId`
* `scopeName`
* `embeddingModel`
* last index run timestamps
* mapping: `chunkKey → contentHash`
* counts and last estimated cost

### 10.5 Upsert plan

On each run:

* Generate chunks from Markdown mirror
* For each chunk:

  * if manifest has same `contentHash` for `chunkKey`: no-op
  * else:

    * obtain embedding from cache, or call embeddings provider and store in cache
    * add to upsert list
* Determine deletes:

  * any `chunkKey` in manifest not present in current chunk set → delete from vector store

### 10.6 Embedding model mismatch policy

Store `modelId` in:

* manifest
* vector metadata
* embedding cache entries

If configured embedding model differs from scope’s stored model:

* Search endpoint must refuse queries with a clear error
* CLI must require explicit `searchsocket index --force` to migrate

No parallel indexes in MVP.

---

## 11. Embeddings Provider

### 11.1 OpenAI embeddings (MVP)

* Model default: `text-embedding-3-small`
* Batch requests (`batchSize`) and concurrency (`concurrency`)
* Retries with exponential backoff on 429/5xx
* Token estimation is required for cost reporting (approximate is acceptable)

---

## 12. Vector Stores

### 12.1 Common record shape

Each vector record stored must include:

* `id`: `chunkKey`
* `vector`: embedding float vector
* `metadata`:

  * `projectId`
  * `scopeName`
  * `url`
  * `title`
  * `sectionTitle`
  * `headingPath` (array or string)
  * `snippet`
  * `contentHash`
  * `modelId`
  * `depth`
  * `incomingLinks`
  * `routeFile`
  * optional `tags`

### 12.2 Pinecone adapter (serverless)

* Index name: default `${projectId}`
* Namespace: `scopeName`
* Upsert by `chunkKey`
* Metadata filters must support:

  * `scopeName` via namespace
  * `url` prefix filtering via `pathPrefix` (implement using metadata `pathSegments` or `path` string and Pinecone filter capabilities)
  * tags filtering

Directory-scoped search:

* Store `path` (e.g., `/docs/getting-started`)
* Support filter: `path STARTS_WITH "/docs"`

  * If Pinecone filter lacks prefix semantics, store additional metadata:

    * `dir0`, `dir1`, `dir2`… or `pathTokens`
  * Implement `pathPrefix` filter using the chosen compatible strategy (must be explicitly implemented and tested).

### 12.3 Milvus Cloud / Zilliz Cloud adapter (serverless)

* Collection: `${projectId}_chunks`
* Schema fields:

  * primary key: `chunkKey` (string)
  * vector: `embedding` (float vector)
  * scalar fields: `scopeName`, `url`, `path`, `title`, `sectionTitle`, `snippet`, `contentHash`, `modelId`, `depth`, `incomingLinks`, `routeFile`, `tags`
* Directory-scoped search:

  * Use scalar filtering on `path` or precomputed directory fields
  * Must support: “search within `/docs`” efficiently

Scope isolation:

* Filter by `scopeName == "<scope>"` (or partitioning if used)
* Deletes by filter for prune operations

### 12.4 Local adapter (offline dev)

* SQLite file: `.searchsocket/local-vectors.json`
* Stores vectors + metadata
* Query uses brute-force cosine similarity
* Supports `pathPrefix` and `tags` filtering locally
* Intended for:

  * local development without credentials
  * small sites (< ~10k chunks) testing

---

## 13. Ranking and Reranking

### 13.1 Base retrieval

* Vector search retrieves `candidateK` hits (default 50)
* Apply lightweight boosts to produce an intermediate score:

  * incoming internal links: `log(1 + incomingLinks)`
  * depth boost: prefer shallow paths (lower depth)

These boosts are minor tie-breakers.

### 13.2 Optional reranker (Jina)

If enabled:

* Send top `candidateK` candidates to Jina reranker
* Receive relevance scores
* Final ordering primarily by reranker score
* Vector score + boosts may be used as stable tie-breakers

### 13.3 No “answer mode”

Search endpoint returns ranked results with snippets only. Any LLM answer layer is out of scope.

---

## 14. Search API (SvelteKit)

### 14.1 Endpoint

`POST /api/search` (configurable via `api.path`)

Request JSON:

```json
{
  "q": "string",
  "topK": 10,
  "scope": "main",
  "pathPrefix": "/docs",
  "tags": ["guides"],
  "rerank": false
}
```

Rules:

* `scope` defaults to resolved scope (usually `main`)
* `pathPrefix` defaults to none (search entire site)
* `rerank` allowed only if configured and server has credentials

Response JSON:

```json
{
  "q": "string",
  "scope": "main",
  "results": [
    {
      "url": "/docs/getting-started",
      "title": "Getting Started",
      "sectionTitle": "Installation",
      "snippet": "…",
      "score": 0.812,
      "routeFile": "src/routes/docs/getting-started/+page.svelte"
    }
  ],
  "meta": {
    "timingsMs": {
      "embed": 12,
      "vector": 34,
      "rerank": 0,
      "total": 55
    },
    "usedRerank": false,
    "modelId": "text-embedding-3-small"
  }
}
```

### 14.2 Error responses

Use structured error codes:

* `CONFIG_MISSING`
* `EMBEDDING_MODEL_MISMATCH`
* `VECTOR_BACKEND_UNAVAILABLE`
* `RATE_LIMITED`
* `INVALID_REQUEST`

### 14.3 SvelteKit integration behavior

`searchsocketHandle()`:

* Server-only; never runs in browser
* Enforces rate limiting if configured
* Applies CORS if configured
* Loads config, initializes providers once (memoized)
* Rejects request bodies above reasonable size

---

## 15. Client Helper (Optional)

Provide a tiny TS helper:

* `createSearchClient({ endpoint?: string })`
* `search({ q, topK, pathPrefix, tags, scope, rerank })`

No UI components are required in MVP.

---

## 16. MCP Server

### 16.1 Entry point

`searchsocket mcp`

Transports:

* `stdio` (default)
* `http` (optional; localhost only by default)

### 16.2 Tools (MVP)

1. `search(query: string, opts?: { scope?: string; topK?: number; pathPrefix?: string; tags?: string[] })`
2. `get_page(pathOrUrl: string, opts?: { scope?: string })`

### 16.3 MCP response requirements

* Every search result must include:

  * `url`
  * `title`
  * `sectionTitle` (if available)
  * `snippet`
  * **`routeFile`** (the original SvelteKit root file, e.g., `.../+page.svelte`)
  * `score`

### 16.4 Route file mapping requirement (critical)

SearchSocket must map each indexed page to a SvelteKit route root file:

* Example:

  * `/docs/getting-started` → `src/routes/docs/getting-started/+page.svelte`
  * `/` → `src/routes/+page.svelte`

Mapping implementation:

* Scan `src/routes/**/+page.svelte` at index time
* Determine which file corresponds to which URL path by SvelteKit routing rules
* Store `routeFile` in Markdown mirror frontmatter and vector metadata
* MCP always returns this `routeFile`

If route resolution is ambiguous:

* Choose the most specific match
* Record `routeResolution: "best-effort"` and still provide a plausible file path

Indexing should fail fast only if the user requests strict mapping mode; otherwise best-effort.

### 16.5 Index management

MCP does not trigger indexing. Agents can invoke CLI commands as needed.

---

## 17. CLI Specification

### 17.1 Commands

#### `searchsocket init`

* Creates `searchsocket.config.ts` minimal
* Prints integration snippet for `src/hooks.server.ts`
* Creates `.searchsocket/` directory

#### `searchsocket index`

Flags:

* `--scope <name>` (override resolved scope)
* `--changed-only` (default)
* `--force` (rebuild Markdown mirror and re-upsert all vectors)
* `--dry-run` (no API calls; compute plan and cost)
* `--source static-output|crawl|content-files`
* `--max-pages N`, `--max-chunks N`
* `--verbose`

Output must include:

* pages processed
* chunks total
* chunks changed
* embeddings reused from cache
* embeddings newly created
* deletes count
* estimated tokens and estimated cost
* elapsed time per stage

#### `searchsocket status`

* Shows:

  * current resolved scope
  * last indexed time per scope (from local manifest and/or registry)
  * vector backend health
  * embedding model ID
  * last estimated cost and tokens

#### `searchsocket dev`

* Watches:

  * `src/routes/**`
  * content directories (if configured)
  * build output directory (if using static-output mode)
* Rebuilds Markdown mirror and reindexes only affected pages
* Defaults to vector backend `local` unless configured otherwise
* Optionally starts MCP server automatically

#### `searchsocket clean`

* Deletes local `.searchsocket/` state
* With `--scope <name> --remote`, deletes vectors for that scope from remote backend

#### `searchsocket prune`

Purpose: prevent orphaned branch scopes from accumulating.

Behavior:

* Lists scopes in backend registry (or best-effort from namespaces/metadata)
* Compares against:

  * `git branch -r` if available, OR
  * a file list `--scopes-file`, OR
  * TTL `--older-than 30d`
* Default: dry-run
* `--apply` performs deletions

#### `searchsocket doctor`

* Validates:

  * config file parse
  * required env vars exist
  * embedding provider connectivity
  * vector backend connectivity
  * can write `.searchsocket/` files

---

## 18. Scope Registry (for pruning and hygiene)

Maintain per-scope registry records with:

* `scopeName`
* `projectId`
* `modelId`
* `lastIndexedAt`
* `vectorCount` (best-effort)

Storage:

* Local: `.searchsocket/registry.json`
* Remote: lightweight registry record stored using the chosen backend strategy:

  * Pinecone: special namespace `_searchsocket_registry`
  * Milvus: separate collection `${projectId}_registry`

`searchsocket prune` relies on this for correctness.

---

## 19. Directory-Scoped Search (“Google-like”)

The search API and MCP must support limiting search to a “directory”:

* `pathPrefix: "/docs"` means:

  * include only URLs whose path begins with `/docs`

Implementation requirements:

* Vector adapters must support filtering by `pathPrefix`:

  * Milvus: scalar filter on stored `path` or precomputed directory tokens
  * Pinecone: implement compatible metadata filtering strategy (precompute directory fields if necessary)
  * Local: string prefix filter

Additionally, support a `site`-style option in future (multiple prefixes), but MVP needs only one prefix.

---

## 20. CI/CD and Workflows

### 20.1 Main branch indexing

Recommended CI:

1. Build site
2. `searchsocket index --changed-only`

### 20.2 Preview branches (opt-in)

If scope mode is `git` or `env`:

* Preview deployment indexes scope = branch
* Set up scheduled prune (or post-merge prune job)

### 20.3 Cost visibility in CI

* `searchsocket index --dry-run` on PRs to report embedding cost
* `searchsocket index` on merge to main

---

## 21. Cost Estimation

SearchSocket must estimate embedding cost before calling embeddings API:

* Estimate tokens per chunk (approximation acceptable)
* Multiply by embedding pricing configured or default pricing table (configurable; printed as estimate)
* Report:

  * `changedChunks`
  * `estimatedTokens`
  * `estimatedCostUSD`

The estimate appears in:

* `searchsocket index --dry-run`
* `searchsocket status`
* `searchsocket index` preflight output

---

## 22. Observability and Logs

* CLI emits structured logs:

  * `page_extracted`, `markdown_written`, `chunked`, `embedded_cached`, `embedded_new`, `upserted`, `deleted`, `registry_updated`
* Each command prints a human summary by default; JSON logs available via `--json`

Search API includes timings in response metadata.

---

## 23. Testing Requirements

### 23.1 Unit tests (pure pipeline)

Must be testable without external services:

* HTML extraction and boilerplate removal
* Markdown conversion determinism
* Chunking boundary rules (code blocks, tables)
* Hash stability and embedding cache behavior
* Route mapping correctness (URL → `+page.svelte`)

### 23.2 Contract tests for vector adapters

* Mock `VectorStore` interface
* Verify:

  * upsert
  * query with filters
  * delete by IDs / scope
  * listing scopes for prune (via registry)

### 23.3 Integration tests (optional)

* Local backend is always testable in CI.
* Milvus docker for optional integration tests (even if production uses cloud).
* Pinecone integration tests gated (if credentials available).

---

## 24. Security Requirements

* All API keys remain server-side.
* Browser receives only search results.
* Support rate limiting on `/api/search` to protect keys and vector quota.
* Respect `noindex` pages by default.
* Provide `data-search-ignore` to prevent indexing sensitive blocks.

---

## 25. Internal Interfaces (Implementation Contracts)

### 25.1 Vector store interface

```ts
interface VectorStore {
  upsert(records: VectorRecord[], scope: Scope): Promise<void>;
  query(queryVector: number[], opts: QueryOpts, scope: Scope): Promise<VectorHit[]>;
  deleteByIds(ids: string[], scope: Scope): Promise<void>;
  deleteScope(scope: Scope): Promise<void>;                 // for prune/clean
  listScopes(): Promise<ScopeInfo[]>;                       // via registry
  health(): Promise<{ ok: boolean; details?: string }>;
}
```

### 25.2 Embeddings interface

```ts
interface EmbeddingsProvider {
  embedTexts(texts: string[], modelId: string): Promise<number[][]>;
  estimateTokens(text: string): number;
}
```

### 25.3 Reranker interface

```ts
interface Reranker {
  rerank(query: string, candidates: { id: string; text: string }[]): Promise<{ id: string; score: number }[]>;
}
```

---

## 26. Definition of Done (MVP)

A project meets MVP when:

1. `searchsocket init` + one-line `hooks.server.ts` exposes `/api/search`.
2. `searchsocket index` builds `.searchsocket/pages/main/**.md`, chunks it, and upserts to Pinecone or Milvus Cloud.
3. `POST /api/search` returns stable ranked results with snippets and includes `routeFile`.
4. `pathPrefix` filtering works and is tested.
5. Incremental indexing avoids re-embedding unchanged content and reuses embedding cache.
6. `searchsocket prune` can list scopes and delete stale scopes safely (dry-run default).
7. `searchsocket mcp` returns results including the SvelteKit `+page.svelte` route root file.

---

## 27. Defaults Summary (Must be implemented)

* Scope: `main`
* Source mode: auto-detect (`static-output` if build output exists; otherwise require explicit)
* Markdown mirror directory: `.searchsocket/pages/<scope>/`
* Embedding model: `text-embedding-3-small`
* Vector backend: user-selected (pinecone/milvus/local)
* Rerank: off by default
* Ranking boosts: incoming links + depth (both on by default)
* API endpoint: `/api/search`
* MCP: enabled in dev, retrieval-only tools

---

This specification is intended to be directly executed by an AI coding agent as a complete build plan: implement the package, CLI, SvelteKit integration, indexing pipeline, Markdown mirror, incremental caching, Pinecone and Milvus Cloud adapters, local adapter, pruning, search endpoint, and MCP retrieval tools with correct route file mapping.
